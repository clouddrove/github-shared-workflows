---
name: üì¶ (Monorepo) Terraform Module Tag Release on Merge

on:
  workflow_call:
    inputs:
      module_prefix:
        required: false
        description: "Provide prefix of directory name containing terraform modules"
        type: string
        default: terraform-aws-

permissions:
  contents: write

jobs:
  release:
    name: üöÄ Release Changed Module
    runs-on: ubuntu-latest

    steps:
      - name: üì¶ Checkout repo
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: üîç Detect changed modules
        id: detect
        env:
          MODULE_PREFIX: ${{ inputs.module_prefix }}
        run: |
          git fetch --tags
          CHANGED_DIRS=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} \
            | grep "^$MODULE_PREFIX" \
            | cut -d '/' -f1 \
            | sort -u \
            | tr '\n' ' ')
          echo "changed=$CHANGED_DIRS" >> "$GITHUB_OUTPUT"

      - name: ‚ö†Ô∏è Fail if no module changed
        if: steps.detect.outputs.changed == ''
        run: |
          echo "No module changes detected. Skipping release."
          exit 1

      - name: üè∑Ô∏è Detect version bumps from commit messages
        if: steps.detect.outputs.changed != ''
        id: version_bump
        run: |
          COMMITS=$(git log ${{ github.event.before }}..${{ github.sha }} --pretty=%B)

          bump_map=""
          for module in ${{ steps.detect.outputs.changed }}; do
            bump="no-release"

            while IFS= read -r commit; do
              if echo "$commit" | grep -q "$module"; then
                if echo "$commit" | grep -qi "major"; then
                  bump="major"
                elif echo "$commit" | grep -qi "minor" && [ "$bump" != "major" ]; then
                  bump="minor"
                elif echo "$commit" | grep -qi "patch" && [ "$bump" = "no-release" ]; then
                  bump="patch"
                fi
              fi
            done <<< "$COMMITS"

            bump_map="$bump_map$module:$bump "
          done

          echo "bump_map=$bump_map" >> "$GITHUB_OUTPUT"

      - name: üîñ Bump version, tag modules, and update changelog
        if: steps.detect.outputs.changed != ''
        run: |
          for entry in ${{ steps.version_bump.outputs.bump_map }}; do
            module=$(echo $entry | cut -d':' -f1)
            bump=$(echo $entry | cut -d':' -f2)

            if [ "$bump" = "no-release" ]; then
              echo "‚ÑπÔ∏è No release requested for $module"
              continue
            fi

            prefix="$module/"
            latest_tag=$(git tag --sort=-v:refname | grep "^$prefix" | grep -E '[0-9]+\.[0-9]+\.[0-9]+$' | cut -d '/' -f2 | head -n 1)
            version=${latest_tag:-0.0.0}
            IFS='.' read -r major minor patch <<< "$version"

            case "$bump" in
              major) major=$((major + 1)); minor=0; patch=0 ;;
              minor) minor=$((minor + 1)); patch=0 ;;
              patch) patch=$((patch + 1)) ;;
            esac

            new_version="$major.$minor.$patch"
            new_tag="$module/$new_version"

            if git rev-parse "$new_tag" >/dev/null 2>&1; then
              echo "‚ö†Ô∏è Tag $new_tag already exists. Skipping."
              continue
            fi

            echo "‚úÖ Creating tag: $new_tag"
            git tag "$new_tag"
            git push origin "$new_tag"

            # --- Update CHANGELOG.md ---
            echo "üìù Updating CHANGELOG.md for $module"
            changelog="CHANGELOG.md"
            repo_url="https://github.com/${{ github.repository }}"

            # Get all tags for this module
            tags=$(git tag --sort=-v:refname | grep "^$prefix" | cut -d '/' -f2)

            # Create new block for this module
            {
              echo "## $module"
              for t in $tags; do
                tag_url="$repo_url/releases/tag/$module/$t"
                if [ "$t" = "$new_version" ]; then
                  echo "- [$t (latest)]($tag_url)"
                else
                  echo "- [$t]($tag_url)"
                fi
              done
              echo
            } > module_changelog.tmp

            # Prepare final changelog
            if [ -f "$changelog" ]; then
              # Remove old section of this module only
              awk -v mod="## $module" '
                BEGIN { skip=0 }
                $0 == mod { skip=1 }
                skip && /^## / && $0 != mod { skip=0 }
                !skip { print }
              ' "$changelog" > changelog.tmp || true

              mv changelog.tmp "$changelog"
            fi

            # Insert module block at alphabetically sorted position
            awk -v mod="## $module" -v file="module_changelog.tmp" '
              BEGIN {
                while ((getline line < file) > 0) newblock = newblock line ORS
                inserted=0
              }
              /^## / {
                if (!inserted && $0 > mod) {
                  printf "%s", newblock
                  inserted=1
                }
              }
              { print }
              END {
                if (!inserted) printf "%s", newblock
              }
            ' "$changelog" > changelog.sorted && mv changelog.sorted "$changelog"

            rm -f module_changelog.tmp

          done

      - name: üì§ Commit and push updated CHANGELOG.md
        run: |
          if git diff --quiet CHANGELOG.md; then
            echo "No CHANGELOG updates"
          else
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add CHANGELOG.md
            git commit -m "üîñ Update CHANGELOG.md"
            git push origin HEAD:${GITHUB_REF#refs/heads/}
          fi
...
